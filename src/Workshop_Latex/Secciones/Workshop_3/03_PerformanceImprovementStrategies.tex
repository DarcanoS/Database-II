\section{Performance Improvement Strategies}

The goal is not to introduce heavy distributed technologies prematurely, but to identify realistic optimizations that match the system’s workload, data characteristics and projected growth.

\subsection{1. Partitioning of Operational and Analytical Data}

\subsubsection*{Rationale}

The platform stores high-frequency air quality readings and generates daily analytical summaries. Although the system currently operates on a single PostgreSQL instance, partitioning can significantly improve query latency and maintenance operations as the dataset grows.

\subsubsection*{Strategy: Temporal Partitioning}

The \texttt{AirQualityReading} table can be divided into monthly partitions. This approach is aligned with the ingestion pattern (continuous, time-ordered data) and the most common dashboard filters (daily or monthly views).

\begin{itemize}[leftmargin=1.5em]
    \item Recent months stay in fast storage for dashboards and near-real-time analytics.
    \item Older partitions can be compressed, moved to cheaper storage, or archived.
\end{itemize}

\subsubsection*{Strategy: Geographic Partitioning (Future)}

If the platform expands beyond a single city or region, additional partitions can be introduced by geographic area (\texttt{country}, \texttt{city}). This hybrid model (time + geography) reduces scan ranges and minimizes contention on the operational store.

\subsubsection*{Benefits}

\begin{itemize}[leftmargin=1.5em]
    \item Faster query execution for dashboards filtered by city or date.
    \item Simplified retention policies, since old partitions can be dropped or archived directly.
    \item Reduced bloat and improved vacuum performance on hot partitions.
\end{itemize}

\subsubsection*{Trade-offs}

\begin{itemize}[leftmargin=1.5em]
    \item Requires discipline in query design to ensure proper use of filters.
    \item Excessive partitions (hundreds) may degrade planning time if not managed.
\end{itemize}

\subsection{2. Read Replicas for Workload Separation}

\subsubsection*{Rationale}

Even in a modest-scale platform, citizen dashboards, research queries and administrative reports can generate substantial read traffic over historical data. These long-running scans may interfere with ingestion jobs or analytical batch operations.

\subsubsection*{Strategy}

Introduce one or more asynchronous read replicas that serve:

\begin{itemize}[leftmargin=1.5em]
    \item Citizen dashboards and maps.
    \item Researcher queries over historical records.
    \item Public-facing visualization endpoints.
\end{itemize}

The primary node focuses exclusively on:

\begin{itemize}[leftmargin=1.5em]
    \item ingesting new measurements,
    \item running validation and normalization steps,
    \item generating daily aggregates.
\end{itemize}

\subsubsection*{Benefits}

\begin{itemize}[leftmargin=1.5em]
    \item Eliminates competition between ingestion and analytical reads.
    \item Reduces latency during peak pollution events when dashboard traffic spikes.
    \item Provides a pathway toward high availability (automatic failover).
\end{itemize}

\subsubsection*{Trade-offs}

\begin{itemize}[leftmargin=1.5em]
    \item Replication lag introduces slight delays in dashboards (a few seconds).
    \item Additional monitoring is required to detect replica staleness.
\end{itemize}

\subsection{3. Parallel Execution for Analytical Queries}

\subsubsection*{Rationale}

The \texttt{AirQualityDailyStats} table is accessed by researchers and public organizations to run long-range analyses. As the table grows (multiple cities, multi-year retention), single-threaded query plans may become slow.

\subsubsection*{Strategy}

Enable PostgreSQL’s parallel query execution mechanisms for:

\begin{itemize}[leftmargin=1.5em]
    \item large temporal scans (multi-month or multi-year),
    \item computations of pollutant averages or correlations,
    \item geospatial filters (bounding boxes or radial searches).
\end{itemize}

Parallel plans distribute segments of the scan across multiple CPU cores, reducing total execution time without modifying the database topology.

\subsubsection*{Benefits}

\begin{itemize}[leftmargin=1.5em]
    \item Significant reductions in analytical query runtime.
    \item Zero changes to application logic.
\end{itemize}

\subsubsection*{Trade-offs}

\begin{itemize}[leftmargin=1.5em]
    \item Requires tuning of PostgreSQL parameters (e.g., \texttt{max\_parallel\_workers\_per\_gather}).
    \item Benefits depend on server CPU availability.
\end{itemize}

\subsection{4. Optimized Batch Ingestion and Daily Aggregation}

\subsubsection*{Rationale}

The ingestion workflow (external APIs → ingestion job → normalizer → PostgreSQL) is executed on a scheduled basis. Although not real-time, it must remain predictable and resilient against API delays or inconsistent data.

\subsubsection*{Strategy}

\begin{itemize}[leftmargin=1.5em]
    \item Use bulk inserts instead of row-by-row ingestion.
    \item Apply batching windows aligned with partition boundaries.
    \item Run daily aggregation during low-traffic periods.
    \item Use indexes optimized for ingestion (e.g., partial indexes on active partitions only).
\end{itemize}

\subsubsection*{Benefits}

\begin{itemize}[leftmargin=1.5em]
    \item Lower write amplification during ingestion.
    \item Guaranteed freshness of daily analytical data.
    \item Stable ingestion latency regardless of traffic patterns.
\end{itemize}

\subsection{5. Caching of Hot Data at the API Layer}

\subsubsection*{Rationale}

Certain values are accessed extremely frequently—such as the latest AQI per station, daily recommendations and alert levels—while being updated only every few minutes.

\subsubsection*{Strategy}

Use a short-lived in-memory cache (within the API server) to store:

\begin{itemize}[leftmargin=1.5em]
    \item latest readings per station,
    \item precomputed recommendation text,
    \item daily aggregates for the current day.
\end{itemize}

\subsubsection*{Benefits}

\begin{itemize}[leftmargin=1.5em]
    \item Reduces repetitive database queries.
    \item Improves responsiveness for high-traffic endpoints.
\end{itemize}

\subsection{6. Summary of Proposed Strategies}

\begin{center}
\begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|}
\hline
\textbf{Strategy} & \textbf{Key Benefit} & \textbf{Main Trade-off} \\
\hline
Temporal and geographic partitioning & Fast, selective scans and easier retention & Requires careful query design and partition management \\
\hline
Read replicas & Offloads dashboards and analytics & Replication lag and additional monitoring \\
\hline
Parallel execution in PostgreSQL & Faster analytical queries with no redesign & Requires parameter tuning and CPU availability \\
\hline
Optimized batch ingestion & Predictable ingestion and cleaner partitions & Requires ingestion window coordination \\
\hline
API-level caching & Reduces repeated DB access & Only useful for short-lived, stable data \\
\hline
\end{tabular}
\end{center}
